package dataset

import (
	"encoding/json"
	"fmt"

	"github.com/ipfs/go-datastore"
)

// Transform is a concrete record of executing an SQL transform. It connects an
// AbstractTransform (which contains all SQL details of the transform) and pointers
// to the datasets that were used in this particular exectution, referenced
// by their abstract name string
type Transform struct {
	// private storage for reference to this object
	path datastore.Key
	// Syntax this transform was written in
	Syntax string `json:"syntax,omitempty"`

	// TODO - currently removing b/c I think this might be too strict.
	// Platform is an identifier for the operating system that performed the transform
	// Platform string `json:"platform,omitempty"`

	// AppVersion is an identifier for the application and version number that produced the result
	AppVersion string
	// Config outlines any configuration that would affect the resulting hash
	Config map[string]interface{}
	// Abstract is the path to the canonicalized version of this transform
	Abstract *AbstractTransform
	// Resources is a map of all datasets referenced in this transform, with alphabetical
	// keys generated by datasets in order of appearance within the transform.
	// all tables referred to in the transform should be present here
	// Keys are _always_ referenced in the form [a-z,aa-zz,aaa-zzz, ...] by order of appearance.
	// The transform itself is rewritten to refer to these table names using bind variables
	Resources map[string]*Dataset
}

// NewTransformRef creates a Transform pointer with the internal
// path property specified, and no other fields.
func NewTransformRef(path datastore.Key) *Transform {
	return &Transform{path: path}
}

// Path gives the internal path reference for this Transform
func (q *Transform) Path() datastore.Key {
	return q.path
}

// IsEmpty checks to see if transform has any fields other than the internal path
func (q *Transform) IsEmpty() bool {
	return q.Abstract == nil && q.Resources == nil
}

// Assign collapses all properties of a group of queries onto one.
// this is directly inspired by Javascript's Object.assign
func (q *Transform) Assign(qs ...*Transform) {
	for _, q2 := range qs {
		if q2 == nil {
			continue
		}
		if q2.Path().String() != "" {
			q.path = q2.path
		}
		if q2.Syntax != "" {
			q.Syntax = q2.Syntax
		}
		if q2.Config != nil {
			if q.Config == nil {
				q.Config = map[string]interface{}{}
			}
			for key, val := range q2.Config {
				q.Config[key] = val
			}
		}
		if q2.Abstract != nil {
			if q.Abstract == nil {
				q.Abstract = &AbstractTransform{}
			}
			q.Abstract.Assign(q2.Abstract)
		}
		if q2.Resources != nil {
			if q.Resources == nil {
				q.Resources = map[string]*Dataset{}
			}
			for key, val := range q2.Resources {
				q.Resources[key] = val
			}
		}
	}
}

// _transform is a private struct for marshaling into & out of.
// fields must remain sorted in lexographical order
type _transform struct {
	Abstract   *AbstractTransform     `json:"abstract,omitempty"`
	AppVersion string                 `json:"appVersion,omitempty"`
	Config     map[string]interface{} `json:"config,omitempty"`
	Resources  map[string]*Dataset    `json:"resources,omitempty"`
	Syntax     string                 `json:"syntax,omitempty"`
}

// MarshalJSON satisfies the json.Marshaler interface
func (q Transform) MarshalJSON() ([]byte, error) {
	// if we're dealing with an empty object that has a path specified, marshal to a string instead
	if q.path.String() != "" && q.IsEmpty() {
		return q.path.MarshalJSON()
	}

	return json.Marshal(&_transform{
		Abstract:   q.Abstract,
		AppVersion: q.AppVersion,
		Config:     q.Config,
		Resources:  q.Resources,
		Syntax:     q.Syntax,
	})
}

// UnmarshalJSON satisfies the json.Unmarshaler interface
func (q *Transform) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err == nil {
		*q = Transform{path: datastore.NewKey(s)}
		return nil
	}

	_q := &_transform{}
	if err := json.Unmarshal(data, _q); err != nil {
		return err
	}

	*q = Transform{
		Abstract:   _q.Abstract,
		AppVersion: _q.AppVersion,
		Config:     _q.Config,
		Resources:  _q.Resources,
		Syntax:     _q.Syntax,
	}
	return nil
}

// UnmarshalTransform tries to extract a resource type from an empty
// interface. Pairs nicely with datastore.Get() from github.com/ipfs/go-datastore
func UnmarshalTransform(v interface{}) (*Transform, error) {
	switch q := v.(type) {
	case *Transform:
		return q, nil
	case Transform:
		return &q, nil
	case []byte:
		transform := &Transform{}
		err := json.Unmarshal(q, transform)
		return transform, err
	default:
		return nil, fmt.Errorf("couldn't parse transform")
	}
}

// AbstractTransform describes an SQL transform on one or more structures
type AbstractTransform struct {
	// private storage for reference to this object
	path datastore.Key
	// Statement is the is parsed & rewritten to a _standard form_ to maximize hash overlap.
	// Writing a transform to it's standard form involves making deterministic choices to
	// remove non-semantic whitespace, rewrite semantically-equivalent terms like "&&" and "AND"
	// to a chosen version, et cetera.
	// Greater precision of transforming format will increase the chances of hash discovery.
	Statement string `json:"statement"`
	// Structure is a path to an algebraic structure that is the _output_ of this structure
	Structure *Structure
	// Structures is a map of all structures referenced in this transform,
	// with alphabetical keys generated by datasets in order of appearance within the transform.
	// Keys are _always_ referenced in the form [a-z,aa-zz,aaa-zzz, ...] by order of appearance.
	// The transform itself is rewritten to refer to these table names using bind variables
	Structures map[string]*Structure `json:"structures"`
	// Syntax is an identifier string for the statement syntax (Eg, "SQL")
	Syntax string `json:"syntax"`
}

// Path gives the internal path reference for this abstract transform
func (q *AbstractTransform) Path() datastore.Key {
	return q.path
}

// NewAbstractTransformRef creates an empty struct with it's internal path set
func NewAbstractTransformRef(path datastore.Key) *AbstractTransform {
	return &AbstractTransform{path: path}
}

// IsEmpty checks to see if AbstractTransform has any fields other than the internal path
func (q *AbstractTransform) IsEmpty() bool {
	return q.Statement == "" && q.Syntax == "" && q.Structure == nil && q.Structures == nil
}

// Assign collapses all properties of a group of AbstractTransform onto one.
// this is directly inspired by Javascript's Object.assign
func (q *AbstractTransform) Assign(aqs ...*AbstractTransform) {
	for _, aq2 := range aqs {
		if aq2 == nil {
			continue
		}
		if aq2.path.String() != "" {
			q.path = aq2.path
		}
		if aq2.Statement != "" {
			q.Statement = aq2.Statement
		}
		if aq2.Structure != nil {
			if q.Structure == nil {
				q.Structure = &Structure{}
			}
			q.Structure.Assign(aq2.Structure)
		}
		if aq2.Structures != nil {
			if q.Structures == nil {
				q.Structures = map[string]*Structure{}
			}
			for key, val := range aq2.Structures {
				q.Structures[key] = val
			}
		}
		if aq2.Syntax != "" {
			q.Syntax = aq2.Syntax
		}
	}
}

// _abstractTransform is a private struct for marshaling into & out of.
// fields must remain sorted in lexographical order
type _abstractTransform struct {
	Structure  *Structure            `json:"outputStructure"`
	Statement  string                `json:"statement"`
	Structures map[string]*Structure `json:"structures"`
	Syntax     string                `json:"syntax"`
}

// MarshalJSON satisfies the json.Marshaler interface
func (q AbstractTransform) MarshalJSON() ([]byte, error) {
	// if we're dealing with an empty object that has a path specified, marshal to a string instead
	if q.path.String() != "" && q.Structure == nil && q.Syntax == "" && q.Structures == nil {
		return q.path.MarshalJSON()
	}

	return json.Marshal(&_abstractTransform{
		Structure:  q.Structure,
		Statement:  q.Statement,
		Structures: q.Structures,
		Syntax:     q.Syntax,
	})
}

// UnmarshalJSON satisfies the json.Unmarshaler interface
func (q *AbstractTransform) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err == nil {
		*q = AbstractTransform{path: datastore.NewKey(s)}
		return nil
	}

	_q := &_abstractTransform{}
	if err := json.Unmarshal(data, _q); err != nil {
		return err
	}

	*q = AbstractTransform{
		Structures: _q.Structures,
		Structure:  _q.Structure,
		Statement:  _q.Statement,
		Syntax:     _q.Syntax,
	}
	return nil
}

// UnmarshalAbstractTransform tries to extract a resource type from an empty
// interface. Pairs nicely with datastore.Get() from github.com/ipfs/go-datastore
func UnmarshalAbstractTransform(v interface{}) (*AbstractTransform, error) {
	switch q := v.(type) {
	case *AbstractTransform:
		return q, nil
	case AbstractTransform:
		return &q, nil
	case []byte:
		transform := &AbstractTransform{}
		err := json.Unmarshal(q, transform)
		return transform, err
	default:
		return nil, fmt.Errorf("couldn't parse abstract transform")
	}
}
